% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bgm.R
\name{bgm}
\alias{bgm}
\title{Bayesian structure learning in Markov Random Fields of mixed binary and
ordinal variables using MCMC.}
\usage{
bgm(
  x,
  iter = 10000,
  burnin = 1000,
  interaction_prior = c("UnitInfo", "Cauchy"),
  cauchy_scale = 2.5,
  threshold_alpha = 1,
  threshold_beta = 1,
  save = FALSE,
  display_progress = TRUE
)
}
\arguments{
\item{x}{An \code{n} by \code{p} matrix containing the binary and ordinal
variables for \code{n} independent observations on \code{p} variables in the
network or graph. If not done already, \code{bgms} recodes the variables as
non-negative integers (i.e., \code{0, 1, ..., m}). Unobserved categories are
collapsed into other categories after recoding. See \code{reformat_data} for
details.}

\item{iter}{The number of iterations of the Gibbs sampler. Defaults to
\code{1e4}. This usually gives a good idea. But for good estimates it is
recommended to run the procedure for \code{1e5} iterations.}

\item{burnin}{The number of burnin iterations. The output of the Gibbs
sampler is stored after \code{burnin} iterations.}

\item{interaction_prior}{The prior distribution for the interaction effects.
Currently, two prior densities are implemented: The Unit Information prior
(\code{interaction_prior = "UnitInfo"}) and the Cauchy prior
(\code{interaction_prior = "Cauchy"}). Defaults to \code{"UnitInfo"}.}

\item{cauchy_scale}{The scale of the Cauchy prior for interactions. Defaults
to \code{2.5}.}

\item{threshold_alpha, threshold_beta}{The shape parameters of the Beta-prime
prior for the thresholds. Defaults to \code{1}.}

\item{save}{Should the function collect and return all samples from the
Gibbs sampler (\code{save = TRUE})? Or should it only return the
(model-averaged) posterior means (\code{save = FALSE})? Defaults to
\code{FALSE}.}

\item{display_progress}{Should the function show a progress bar
(\code{display_progress = TRUE})? Or not (\code{display_progress = FALSE})?
Defauls to \code{TRUE}.}
}
\value{
If \code{save = FALSE} (the default), a list containing the
\code{p} by \code{p} matrices \code{gamma} and \code{interactions}, and the
\code{p} by \code{max(no_categories)} matrix \code{thresholds}. The matrix
\code{gamma} is a numeric matrix that contains the inclusion probabilities
for individual edges. The matrices \code{interactions} and \code{thresholds}
are numeric matrices that contain the (model or structure-averaged) posterior
means (EAP estimates) of the pairwise associations, and category thresholds,
respectively. If \code{save = TRUE}, a list containing the
\code{iter} by \code{p *  (p - 1) / 2} matrices \code{samples.gamma}
and \code{samples.interactions}, and the \code{iter} by
\code{sum(no_categories)} matrix \code{samples.thresholds}. These contain the
parameter states at every iteration of the Gibbs sampler. Column averages
offer the EAP estimates.
}
\description{
The function \code{bgm} explores the joint pseudoposterior distribution of
structures and parameters in a Markov Random Field for mixed binary and
ordinal variables.
}
\details{
A discrete spike and slab prior distribution is stipulated on the pairwise
interactions. By formulating it as a mixture of mutually singular
distributions, the function can use a combination of Metropolis-Hastings and
Gibbs sampling to create a Markov chain that has the joint posterior
distribution as invariant. Current options for the slab distribution are the
unit-information prior or a Cauchy with an optional scaling parameter. A
Beta-prime distribution is used for the exponent of the category parameters.
A uniform prior is used for edge inclusion variables (i.e., the prior
probability that the edge is included is 0.5).
}
\examples{
\dontrun{
 ##Analyse the Wenchuan dataset

 # Here, we use 1e4 iterations, for an actual analysis please use at least
 # 1e5 iterations.
 fit = bgm(x = Wenchuan)


 #------------------------------------------------------------------------------|
 # INCLUSION - EDGE WEIGHT PLOT
 #------------------------------------------------------------------------------|

 par(mar = c(6, 5, 1, 1))
 plot(x = fit$interactions[lower.tri(fit$interactions)],
      y = fit$gamma[lower.tri(fit$gamma)], ylim = c(0, 1),
      xlab = "", ylab = "", axes = FALSE, pch = 21, bg = "gray", cex = 1.3)
 abline(h = 0, lty = 2, col = "gray")
 abline(h = 1, lty = 2, col = "gray")
 abline(h = .5, lty = 2, col = "gray")
 mtext("Posterior Inclusion Probability", side = 1, line = 3, cex = 1.7)
 mtext("Posterior Mode Edge Weight", side = 2, line = 3, cex = 1.7)
 axis(1)
 axis(2, las = 1)


 #------------------------------------------------------------------------------|
 # EVIDENCE - EDGE WEIGHT PLOT
 #------------------------------------------------------------------------------|

 #The bgms package currently assumes that the prior odds are 1:
 prior.odds = 1
 posterior.inclusion = fit$gamma[lower.tri(fit$gamma)]
 posterior.odds = posterior.inclusion / (1 - posterior.inclusion)
 log.bayesfactor = log(posterior.odds / prior.odds)
 log.bayesfactor[log.bayesfactor > 5] = 5

 par(mar = c(5, 5, 1, 1) + 0.1)
 plot(fit$interactions[lower.tri(fit$interactions)], log.bayesfactor, pch = 21, bg = "#bfbfbf",
      cex = 1.3, axes = FALSE, xlab = "", ylab = "", ylim = c(-5, 5.5),
      xlim = c(-0.5, 1.5))
 axis(1)
 axis(2, las = 1)
 abline(h = log(1/10), lwd = 2, col = "#bfbfbf")
 abline(h = log(10), lwd = 2, col = "#bfbfbf")

 text(x = 1, y = log(1 / 10), labels = "Evidence for Exclusion", pos = 1,
      cex = 1.7)
 text(x = 1, y = log(10), labels = "Evidence for Inclusion", pos = 3, cex = 1.7)
 text(x = 1, y = 0, labels = "Absence of Evidence", cex = 1.7)
 mtext("Log-Inclusion Bayes Factor", side = 2, line = 3, cex = 1.5, las = 0)
 mtext("Posterior Mean Interactions ", side = 1, line = 3.7, cex = 1.5, las = 0)


 #------------------------------------------------------------------------------|
 # THE LOCAL MEDIAN PROBABILITY NETWORK
 #------------------------------------------------------------------------------|

 tmp = fit$interactions[lower.tri(fit$interactions)]
 tmp[posterior.inclusion < 0.5] = 0

 median.prob.model = matrix(0, nrow = ncol(Wenchuan), ncol = ncol(Wenchuan))
 median.prob.model[lower.tri(median.prob.model)] = tmp
 median.prob.model = median.prob.model + t(median.prob.model)

 rownames(median.prob.model) = colnames(Wenchuan)
 colnames(median.prob.model) = colnames(Wenchuan)

 library(qgraph)
 qgraph(median.prob.model,
        theme = "TeamFortress",
        maximum = .5,
        fade = FALSE,
        color = c("#f0ae0e"), vsize = 10, repulsion = .9,
        label.cex = 1.1, label.scale = "FALSE",
        labels = colnames(Wenchuan))
 }
}
