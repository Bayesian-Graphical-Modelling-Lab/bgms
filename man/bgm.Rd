% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bgm.R
\name{bgm}
\alias{bgm}
\title{Bayesian Estimation or Edge Selection for Markov Random Fields}
\usage{
bgm(
  x,
  variable_type = "ordinal",
  reference_category,
  iter = 10000,
  burnin = 500,
  interaction_scale = 2.5,
  threshold_alpha = 0.5,
  threshold_beta = 0.5,
  edge_selection = TRUE,
  edge_prior = c("Bernoulli", "Beta-Bernoulli", "Stochastic-Block"),
  inclusion_probability = 0.5,
  beta_bernoulli_alpha = 1,
  beta_bernoulli_beta = 1,
  dirichlet_alpha = 1,
  lambda = 1,
  na_action = c("listwise", "impute"),
  save = FALSE,
  display_progress = TRUE
)
}
\arguments{
\item{x}{A data frame or matrix with \code{n} rows and \code{p} columns containing binary and ordinal responses. Binary and ordinal variables are automatically recoded to non-negative integers (\code{0, 1, ..., m}). For regular ordinal variables, unobserved categories are collapsed; for Blume-Capel variables, all categories are retained.}

\item{variable_type}{Character or character vector. Specifies the type of each variable in \code{x}. Allowed values: \code{"ordinal"} or \code{"blume-capel"}. Binary variables are automatically treated as \code{"ordinal"}. Default: \code{"ordinal"}.}

\item{reference_category}{Integer or vector. Reference category used in Blume-Capel variables. Can be a single integer (applied to all) or a vector of length \code{p}. Required if at least one variable is of type \code{"blume-capel"}.}

\item{iter}{Integer. Number of Gibbs sampling iterations. Default: \code{1e4}. For stable estimates, consider using at least \code{1e5}.}

\item{burnin}{Integer. Number of burn-in iterations before saving samples. When \code{edge_selection = TRUE}, the function runs \code{2 * burnin} iterations: first half without edge selection, second half with edge selection. Default: \code{1e3}.}

\item{interaction_scale}{Double. Scale of the Cauchy prior for pairwise interaction parameters. Default: \code{2.5}.}

\item{threshold_alpha, threshold_beta}{Double. Shape parameters of the beta-prime prior for threshold parameters. Must be positive. If equal, the prior is symmetric. Defaults: \code{threshold_alpha = 0.5} and \code{threshold_beta = 0.5}.}

\item{edge_selection}{Logical. Whether to perform Bayesian edge selection. If \code{FALSE}, the model estimates all edges. Default: \code{TRUE}.}

\item{edge_prior}{Character. Specifies the prior for edge inclusion. Options:
\code{"Bernoulli"}, \code{"Beta-Bernoulli"}, or \code{"Stochastic-Block"}. Default: \code{"Bernoulli"}.}

\item{inclusion_probability}{Numeric scalar or matrix. Prior inclusion probability of each edge (used with the Bernoulli prior). A single value applies to all edges; a matrix allows edge-specific probabilities. Default: \code{0.5}.}

\item{beta_bernoulli_alpha, beta_bernoulli_beta}{Double. Shape parameters for the beta distribution in the Beta-Bernoulli prior. Must be positive. Defaults: \code{beta_bernoulli_alpha = 1} and \code{beta_bernoulli_beta = 1}.}

\item{dirichlet_alpha}{Double. Concentration parameter of the Dirichlet prior on block assignments (used with the Stochastic Block Model). Default: \code{1}.}

\item{lambda}{Double. Rate of the zero-truncated Poisson prior on the number of clusters in the Stochastic Block Model. Default: \code{1}.}

\item{na_action}{Character. Specifies missing data handling. \code{"listwise"} deletes rows with missing values. \code{"impute"} imputes missing values during MCMC. Default: \code{"listwise"}.}

\item{save}{Logical; \strong{deprecated}. Whether to return all sampled states from the Gibbs sampler. If \code{FALSE}, only posterior means are returned. Default: \code{FALSE}.}

\item{display_progress}{Logical. Whether to show a progress bar during sampling. Default: \code{TRUE}.}
}
\value{
A list of class \code{"bgms"} containing posterior summaries or sampled states, depending on the \code{save} option:

\strong{If \code{save = FALSE}} (default), the list contains model-averaged posterior summaries:
\itemize{
  \item \code{indicator}: A \code{p × p} matrix of posterior inclusion probabilities for each edge.
  \item \code{interactions}: A \code{p × p} matrix of posterior means for pairwise interactions.
  \item \code{thresholds}: A \code{p × max(m)} matrix of posterior means for threshold parameters. For Blume-Capel variables, the first entry corresponds to the linear term and the second to the quadratic term.
}

\strong{If \code{save = TRUE}}, the list also includes raw MCMC samples:
\itemize{
  \item \code{indicator}: A matrix with \code{iter} rows and \code{p × (p - 1) / 2} columns; sampled edge inclusion indicators.
  \item \code{interactions}: A matrix with \code{iter} rows and \code{p × (p - 1) / 2} columns; sampled interaction parameters.
  \item \code{thresholds}: A matrix with \code{iter} rows and \code{sum(m)} columns; sampled threshold parameters.
}

\strong{If \code{edge_prior = "Stochastic-Block"}}, two additional components may be returned:
\itemize{
  \item \code{allocations}: A vector (or matrix if \code{save = TRUE}) with posterior cluster assignments for each node.
  \item \code{components}: A matrix of posterior probabilities for the number of clusters, based on sampled allocations.
}

Column-wise averages of the sampled matrices yield posterior means, except for \code{allocations}, which should be summarized using \code{summarySBM()}.

The returned list also includes some of the function call arguments, useful for post-processing.
}
\description{
The \code{bgm} function estimates the pseudoposterior distribution of threshold and
pairwise interaction parameters in a Markov Random Field (MRF) model for binary and/or
ordinal variables. Optionally, it performs Bayesian edge selection using spike-and-slab
priors to infer the network structure.
}
\details{
This function models the joint distribution of binary and ordinal variables
using a Markov Random Field, with support for edge selection through Bayesian
variable selection. Key components of the model are described in the sections below.
}
\section{Ordinal Variables}{

The function supports two types of ordinal variables:

\strong{Regular ordinal variables}:
Assign a threshold parameter to each response category except the lowest. The model imposes no additional constraints on the distribution of category responses.

\strong{Blume-Capel ordinal variables}:
Assume a reference category (e.g., a “neutral” response) and score responses by distance from this reference. Thresholds are modeled quadratically:

\deqn{\mu_{c} = \alpha \cdot c + \beta \cdot (c - r)^2}

where:
\itemize{
  \item \eqn{\mu_{c}}: threshold for category \eqn{c}
  \item \eqn{\alpha}: linear trend across categories
  \item \eqn{\beta}: preference toward or away from the reference
   \itemize{
     \item If \eqn{\beta < 0}, the model favors responses near the reference category;
     \item if \eqn{\beta > 0}, it favors responses farther away (i.e., extremes).
   }
  \item \eqn{r}: reference category
}
}

\section{Edge Selection}{

When \code{edge_selection = TRUE}, the function performs Bayesian variable selection
on the pairwise interactions (edges) in the MRF using spike-and-slab priors.

Supported priors for edge inclusion:
\itemize{
  \item \strong{Bernoulli}: Fixed inclusion probability across edges.
  \item \strong{Beta-Bernoulli}: Inclusion probability is assigned a Beta prior distribution.
  \item \strong{Stochastic Block Model}: Cluster-based edge priors with Beta, Dirichlet, and Poisson hyperpriors.
}

All priors operate via binary indicator variables controlling the inclusion or exclusion of each edge.
}

\section{Prior Distributions}{


\itemize{
  \item \strong{Interaction parameters}: Modeled with a Cauchy slab prior.
  \item \strong{Threshold parameters}: Modeled using a beta-prime distribution.
  \item \strong{Edge indicators}: Use either a Bernoulli, Beta-Bernoulli, or SBM prior (as above).
}
}

\section{Gibbs Sampling}{


Parameters are estimated using a Metropolis-within-Gibbs sampling scheme.
When \code{edge_selection = TRUE}, the algorithm runs \code{2 * burnin} warmup iterations:
\itemize{
  \item First half without edge selection.
  \item Second half with edge selection enabled.
}
This warmup strategy improves stability of adaptive Metropolis-Hastings proposals and starting values.
}

\section{Missing Data}{


If \code{na_action = "listwise"}, observations with missing values are removed.
If \code{na_action = "impute"}, missing values are imputed during MCMC.
}

\examples{
\donttest{
# Store user par() settings
op <- par(no.readonly = TRUE)

# Run bgm on the Wenchuan dataset
# For reliable results, consider using at least 1e5 iterations
fit <- bgm(x = Wenchuan, iter = 1e4)

#--- INCLUSION VS EDGE WEIGHT ----------------------------------------------
edge_weights <- fit$interactions[lower.tri(fit$interactions)]
incl_probs   <- fit$indicator[lower.tri(fit$indicator)]

par(mar = c(5, 5, 1, 1) + 0.1, cex = 1.7)
plot(edge_weights, incl_probs,
     pch = 21, bg = "gray", cex = 1.3,
     ylim = c(0, 1), axes = FALSE,
     xlab = "", ylab = "")
abline(h = c(0, 0.5, 1), lty = 2, col = "gray")
axis(1); axis(2, las = 1)
mtext("Posterior Mean Edge Weight", side = 1, line = 3, cex = 1.7)
mtext("Posterior Inclusion Probability", side = 2, line = 3, cex = 1.7)

#--- EVIDENCE PLOT ----------------------------------------------------------
prior_odds <- 1
post_odds <- incl_probs / (1 - incl_probs)
log_bf <- log(post_odds / prior_odds)
log_bf <- pmin(log_bf, 5)  # cap extreme values

plot(edge_weights, log_bf,
     pch = 21, bg = "#bfbfbf", cex = 1.3,
     axes = FALSE, xlab = "", ylab = "",
     ylim = c(-5, 5.5), xlim = c(-0.5, 1.5))
axis(1); axis(2, las = 1)
abline(h = log(c(1/10, 10)), lwd = 2, col = "#bfbfbf")
text(1, log(1 / 10), "Evidence for Exclusion", pos = 1, cex = 1.1)
text(1, log(10),     "Evidence for Inclusion", pos = 3, cex = 1.1)
text(1, 0,           "Absence of Evidence", cex = 1.1)
mtext("Log-Inclusion Bayes Factor", side = 2, line = 3, cex = 1.7)
mtext("Posterior Mean Interactions", side = 1, line = 3.7, cex = 1.7)

#--- MEDIAN PROBABILITY NETWORK --------------------------------------------
median_edges <- ifelse(incl_probs >= 0.5, edge_weights, 0)
n <- ncol(Wenchuan)
net <- matrix(0, n, n)
net[lower.tri(net)] <- median_edges
net <- net + t(net)
dimnames(net) <- list(colnames(Wenchuan), colnames(Wenchuan))

par(cex = 1)
if (requireNamespace("qgraph", quietly = TRUE)) {
  qgraph::qgraph(net,
    theme = "TeamFortress", maximum = 0.5, fade = FALSE,
    color = "#f0ae0e", vsize = 10, repulsion = 0.9,
    label.cex = 1.1, label.scale = FALSE,
    labels = colnames(Wenchuan)
  )
}

# Restore user par() settings
par(op)
}

}
\references{
\insertAllCited{}
}
